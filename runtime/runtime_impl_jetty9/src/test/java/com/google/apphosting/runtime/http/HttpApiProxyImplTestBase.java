/*
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.apphosting.runtime.http;

import com.google.apphosting.api.CloudTraceContext;
import com.google.apphosting.base.protos.TracePb.TraceContextProto;
import com.google.apphosting.base.protos.api_bytes.RemoteApiPb;
import com.google.apphosting.runtime.ApiProxyImpl;
import com.google.apphosting.runtime.MutableUpResponse;
import com.google.apphosting.runtime.TraceWriter;
import com.google.apphosting.runtime.grpc.FakeApiProxyImplFactory;
import com.google.apphosting.testing.PortPicker;
import com.google.common.collect.ImmutableList;
import com.google.protobuf.ByteString;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.InvalidProtocolBufferException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Random;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

/** Parent class for tests for HTTP-based APIHost traffic. */
public class HttpApiProxyImplTestBase {
  @Parameters(name = "{0}:{1}")
  public static Collection<Object[]> parameters() {
    return ImmutableList.copyOf(
        new Object[][] {
          {
            HttpApiHostClient.Config.builder().build(), null,
          },
          {
            HttpApiHostClient.Config.builder().setIgnoreContentLength(true).build(), null,
          },
          {
            HttpApiHostClient.Config.builder().build(),
            "com.google.appengine.api.calls.using.jdk.client",
          },
        });
  }

  @Parameter(0)
  public HttpApiHostClient.Config config;

  @Parameter(1)
  public String propertyToSet;

  static final String API_DEADLINE_KEY = "com.google.apphosting.api.ApiProxy.api_deadline_key";
  static final String ECHO_SERVICE = "echo";
  static final String DELAY_METHOD = "Delay";
  static final String ECHO_METHOD = "Echo";
  static final String ERROR_METHOD = "Error";
  static final String SWALLOW_METHOD = "Swallow";
  static final String SPEW_METHOD = "Spew";
  static final String BAD_METHOD = "Bad";
  static final String FAKE_SECURITY_TICKET = "tickety-boo";
  static final int FAKE_APPLICATION_ERROR = 23;
  static final String FAKE_ERROR_DETAIL = "something bad happened";

  static FakeHttpApiHost fakeHttpApiHost;
  static CloudTraceContext cloudTraceContext;

  @BeforeClass
  public static void setUpClass() throws Exception {
    int port = PortPicker.create().pickUnusedPort();
    Random random = new Random(1234);
    // Generate a traceId with the same size as the one generated by the Appserver.
    byte[] traceId = new byte[18];
    random.nextBytes(traceId);
    cloudTraceContext =
        new CloudTraceContext(traceId, /* spanId= */ random.nextLong(), /* traceMask= */ 1);
    fakeHttpApiHost = FakeHttpApiHost.create(port, new EchoHandler());
  }

  @Before
  public void setUp() {
    if (propertyToSet != null) {
      System.setProperty(propertyToSet, "true");
    }
  }

  @After
  public void tearDown() {
    // The current test method may or may not have frozen fakeHttpApiHost. Unfreeze it anyway.
    fakeHttpApiHost.unfreeze();
    if (propertyToSet != null) {
      System.clearProperty(propertyToSet);
    }
  }

  @AfterClass
  public static void tearDownClass() {
    fakeHttpApiHost.stop();
  }

  ApiProxyImpl newApiProxyImpl() {
    HttpApiHostClient apiHostClient =
        HttpApiHostClient.create(fakeHttpApiHost.getUrl().toString(), config);
    return FakeApiProxyImplFactory.newApiProxyImpl(apiHostClient);
  }

  ApiProxyImpl.EnvironmentImpl newEnvironmentImpl(ApiProxyImpl apiProxyImpl) {
    return FakeApiProxyImplFactory.fakeEnvironment(
        apiProxyImpl,
        FAKE_SECURITY_TICKET,
        new TraceWriter(cloudTraceContext, new MutableUpResponse()));
  }

  static class EchoHandler implements FakeHttpApiHost.ApiRequestHandler {
    @Override
    public RemoteApiPb.Response handle(RemoteApiPb.Request request) {
      if (!request.getServiceName().equals(ECHO_SERVICE)) {
        throw new IllegalArgumentException("Unexpected request: " + request);
      }
      if (!request.getRequestId().equals(FAKE_SECURITY_TICKET)) {
        throw new IllegalArgumentException(
            "Wrong security ticket: '" + request.getRequestId() + "'");
      }
      // The ProxyApiImpl will change the SpanId because it creates a new Span.
      TraceContextProto.Builder traceContext = TraceContextProto.newBuilder();
      try {
        traceContext.mergeFrom(request.getTraceContext(), ExtensionRegistry.getEmptyRegistry());
      } catch (InvalidProtocolBufferException e) {
        throw new AssertionError(e);
      }
      if (!traceContext.getTraceId().equals(ByteString.copyFrom(cloudTraceContext.getTraceId()))) {
        return newAppErrorResponse(
                FAKE_APPLICATION_ERROR,
                String.format("Wrong traceId: '%s'", traceContext.getTraceId()))
            .build();
      }
      if (traceContext.getTraceMask() != cloudTraceContext.getTraceMask()) {
        return newAppErrorResponse(
                FAKE_APPLICATION_ERROR,
                String.format("Wrong traceMask: '%s'", traceContext.getTraceMask()))
            .build();
      }
      RemoteApiPb.Response.Builder response = RemoteApiPb.Response.newBuilder();
      ByteString payload = request.getRequest();
      switch (request.getMethod()) {
        case DELAY_METHOD:
          // Payload is a UTF-8 string that is a floating-point delay in seconds.
          String delayString = payload.toStringUtf8();
          double delay = Double.parseDouble(delayString);
          long delayMs = (long) (delay * 1000);
          try {
            Thread.sleep(delayMs);
          } catch (InterruptedException e) {
            throw new RuntimeException(e);
          }
          break;
        case ECHO_METHOD:
          response.setResponse(payload);
          break;
        case ERROR_METHOD:
          response = newAppErrorResponse(FAKE_APPLICATION_ERROR, FAKE_ERROR_DETAIL);
          break;
        case SWALLOW_METHOD:
          response.setResponse(ByteString.EMPTY);
          break;
        case SPEW_METHOD:
          // Payload is a UTF-8 string that says how many bytes to reply with.
          String spewSizeString = payload.toStringUtf8();
          int spewSize = Integer.parseInt(spewSizeString);
          byte[] spew = new byte[spewSize];
          Arrays.fill(spew, (byte) 88);
          response.setResponse(ByteString.copyFrom(spew));
          break;
        case BAD_METHOD:
          response.setResponse(FakeHttpApiHost.BAD_RESPONSE);
          break;
        default:
          throw new AssertionError(request.getMethod());
      }
      return response.build();
    }
  }

  private static RemoteApiPb.Response.Builder newAppErrorResponse(int code, String detail) {
    RemoteApiPb.ApplicationError applicationError =
        RemoteApiPb.ApplicationError.newBuilder().setCode(code).setDetail(detail).build();
    return RemoteApiPb.Response.newBuilder().setApplicationError(applicationError);
  }
}
